
import { AptosParserRepo, getTypeTagFullname, StructTag, parseTypeTagOrThrow, u8, u64, u128, print, strToU8, u8str, DummyCache, ActualStringClass, sendPayloadTx, sendPayloadTxAndLog, getSimulationKeys } from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Coin_list from './coin_list';
import * as Econia from './econia';
import * as Hippo_aggregator from './hippo_aggregator';
import * as Sample from './sample';
import { TradeAggregator } from "@manahippo/hippo-sdk";
import { buildPayload_swap_and_transfer } from "./sample/sample";

export const readConfig = (program: Command) => {
  const {config, profile} = program.opts();
  const ymlContent = fs.readFileSync(config, {encoding: "utf-8"});
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return {client, account};
}

const program = new Command();

program
  .name('yarn cli')
  .description('Move TS CLI generated by move-to-ts')
  .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
  .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default')


const coin_list_add_approver_to_list = async (approver: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_approver_to_list(approver_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:add-approver-to-list")
  .description("")
  .argument('<approver>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_add_approver_to_list);


const coin_list_add_approver_to_registry = async (approver: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_approver_to_registry(approver_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:add-approver-to-registry")
  .description("")
  .argument('<approver>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_add_approver_to_registry);


const coin_list_add_extension = async (CoinType: string,key: string,value: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const key_ = new ActualStringClass({bytes: strToU8(key)}, parseTypeTagOrThrow('0x1::string::String'));
  const value_ = new ActualStringClass({bytes: strToU8(value)}, parseTypeTagOrThrow('0x1::string::String'));
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_extension(key_, value_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:add-extension")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<key>')
  .argument('<value>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_add_extension);


const coin_list_add_to_list = async (CoinType: string,list: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const list_ = new HexString(list);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_to_list(list_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:add-to-list")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<list>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_add_to_list);


const coin_list_add_to_registry_by_approver = async (CoinType: string,name: string,symbol: string,coingecko_id: string,logo_url: string,project_url: string,is_update: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const name_ = new ActualStringClass({bytes: strToU8(name)}, parseTypeTagOrThrow('0x1::string::String'));
  const symbol_ = new ActualStringClass({bytes: strToU8(symbol)}, parseTypeTagOrThrow('0x1::string::String'));
  const coingecko_id_ = new ActualStringClass({bytes: strToU8(coingecko_id)}, parseTypeTagOrThrow('0x1::string::String'));
  const logo_url_ = new ActualStringClass({bytes: strToU8(logo_url)}, parseTypeTagOrThrow('0x1::string::String'));
  const project_url_ = new ActualStringClass({bytes: strToU8(project_url)}, parseTypeTagOrThrow('0x1::string::String'));
  const is_update_ = is_update=='true';
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_to_registry_by_approver(name_, symbol_, coingecko_id_, logo_url_, project_url_, is_update_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:add-to-registry-by-approver")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<name>')
  .argument('<symbol>')
  .argument('<coingecko_id>')
  .argument('<logo_url>')
  .argument('<project_url>')
  .argument('<is_update>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_add_to_registry_by_approver);


const coin_list_add_to_registry_by_signer = async (CoinType: string,name: string,symbol: string,coingecko_id: string,logo_url: string,project_url: string,is_update: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const name_ = new ActualStringClass({bytes: strToU8(name)}, parseTypeTagOrThrow('0x1::string::String'));
  const symbol_ = new ActualStringClass({bytes: strToU8(symbol)}, parseTypeTagOrThrow('0x1::string::String'));
  const coingecko_id_ = new ActualStringClass({bytes: strToU8(coingecko_id)}, parseTypeTagOrThrow('0x1::string::String'));
  const logo_url_ = new ActualStringClass({bytes: strToU8(logo_url)}, parseTypeTagOrThrow('0x1::string::String'));
  const project_url_ = new ActualStringClass({bytes: strToU8(project_url)}, parseTypeTagOrThrow('0x1::string::String'));
  const is_update_ = is_update=='true';
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_to_registry_by_signer(name_, symbol_, coingecko_id_, logo_url_, project_url_, is_update_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:add-to-registry-by-signer")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<name>')
  .argument('<symbol>')
  .argument('<coingecko_id>')
  .argument('<logo_url>')
  .argument('<project_url>')
  .argument('<is_update>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_add_to_registry_by_signer);


const coin_list_create_list = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_create_list();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:create-list")
  .description("")
  .argument('[max_gas]', '', '10000')
  .action(coin_list_create_list);


const coin_list_drop_extension = async (CoinType: string,key: string,value: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const key_ = new ActualStringClass({bytes: strToU8(key)}, parseTypeTagOrThrow('0x1::string::String'));
  const value_ = new ActualStringClass({bytes: strToU8(value)}, parseTypeTagOrThrow('0x1::string::String'));
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_drop_extension(key_, value_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:drop-extension")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<key>')
  .argument('<value>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_drop_extension);


const coin_list_initialize = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_initialize();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:initialize")
  .description("")
  .argument('[max_gas]', '', '10000')
  .action(coin_list_initialize);


const coin_list_remove_approver_from_list = async (approver: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_remove_approver_from_list(approver_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:remove-approver-from-list")
  .description("")
  .argument('<approver>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_remove_approver_from_list);


const coin_list_remove_approver_from_registry = async (approver: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_remove_approver_from_registry(approver_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:remove-approver-from-registry")
  .description("")
  .argument('<approver>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_remove_approver_from_registry);


const coin_list_remove_from_list = async (CoinType: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_remove_from_list([CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:remove-from-list")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_remove_from_list);


const coin_list_remove_from_registry_by_approver = async (CoinType: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_remove_from_registry_by_approver([CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:remove-from-registry-by-approver")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_remove_from_registry_by_approver);


const coin_list_remove_from_registry_by_signer = async (CoinType: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_remove_from_registry_by_signer([CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("coin-list:remove-from-registry-by-signer")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_remove_from_registry_by_signer);


const devnet_coins_mint_to_wallet = async (CoinType: string,amount: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Devnet_coins.buildPayload_mint_to_wallet(amount_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("devnet-coins:mint-to-wallet")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<amount>')
  .argument('[max_gas]', '', '10000')
  .action(devnet_coins_mint_to_wallet);


const assets_init_coin_types = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Assets.buildPayload_init_coin_types();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("assets:init-coin-types")
  .description("")
  .argument('[max_gas]', '', '10000')
  .action(assets_init_coin_types);


const assets_mint = async (CoinType: string,amount: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Assets.buildPayload_mint(amount_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("assets:mint")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<amount>')
  .argument('[max_gas]', '', '10000')
  .action(assets_mint);


const market_cancel_all_limit_orders_user = async (host: string,market_id: string,side: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side=='true';
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_cancel_all_limit_orders_user(host_, market_id_, side_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("market:cancel-all-limit-orders-user")
  .description("")
  .argument('<host>')
  .argument('<market_id>')
  .argument('<side>')
  .argument('[max_gas]', '', '10000')
  .action(market_cancel_all_limit_orders_user);


const market_cancel_limit_order_user = async (host: string,market_id: string,side: string,order_id: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side=='true';
  const order_id_ = u128(order_id);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_cancel_limit_order_user(host_, market_id_, side_, order_id_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("market:cancel-limit-order-user")
  .description("")
  .argument('<host>')
  .argument('<market_id>')
  .argument('<side>')
  .argument('<order_id>')
  .argument('[max_gas]', '', '10000')
  .action(market_cancel_limit_order_user);


const market_place_limit_order_user = async (BaseType: string,QuoteType: string,host: string,market_id: string,side: string,size: string,price: string,post_or_abort: string,fill_or_abort: string,immediate_or_cancel: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side=='true';
  const size_ = u64(size);
  const price_ = u64(price);
  const post_or_abort_ = post_or_abort=='true';
  const fill_or_abort_ = fill_or_abort=='true';
  const immediate_or_cancel_ = immediate_or_cancel=='true';
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_place_limit_order_user(host_, market_id_, side_, size_, price_, post_or_abort_, fill_or_abort_, immediate_or_cancel_, [BaseType_, QuoteType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("market:place-limit-order-user")
  .description("")
  .argument('<TYPE_BaseType>')
  .argument('<TYPE_QuoteType>')
  .argument('<host>')
  .argument('<market_id>')
  .argument('<side>')
  .argument('<size>')
  .argument('<price>')
  .argument('<post_or_abort>')
  .argument('<fill_or_abort>')
  .argument('<immediate_or_cancel>')
  .argument('[max_gas]', '', '10000')
  .action(market_place_limit_order_user);


const market_place_market_order_user = async (BaseType: string,QuoteType: string,host: string,market_id: string,direction: string,min_base: string,max_base: string,min_quote: string,max_quote: string,limit_price: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const direction_ = direction=='true';
  const min_base_ = u64(min_base);
  const max_base_ = u64(max_base);
  const min_quote_ = u64(min_quote);
  const max_quote_ = u64(max_quote);
  const limit_price_ = u64(limit_price);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_place_market_order_user(host_, market_id_, direction_, min_base_, max_base_, min_quote_, max_quote_, limit_price_, [BaseType_, QuoteType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("market:place-market-order-user")
  .description("")
  .argument('<TYPE_BaseType>')
  .argument('<TYPE_QuoteType>')
  .argument('<host>')
  .argument('<market_id>')
  .argument('<direction>')
  .argument('<min_base>')
  .argument('<max_base>')
  .argument('<min_quote>')
  .argument('<max_quote>')
  .argument('<limit_price>')
  .argument('[max_gas]', '', '10000')
  .action(market_place_market_order_user);


const market_register_market_pure_coin = async (BaseCoinType: string,QuoteCoinType: string,lot_size: string,tick_size: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const BaseCoinType_ = parseTypeTagOrThrow(BaseCoinType);
  const QuoteCoinType_ = parseTypeTagOrThrow(QuoteCoinType);
  const lot_size_ = u64(lot_size);
  const tick_size_ = u64(tick_size);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_register_market_pure_coin(lot_size_, tick_size_, [BaseCoinType_, QuoteCoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("market:register-market-pure-coin")
  .description("")
  .argument('<TYPE_BaseCoinType>')
  .argument('<TYPE_QuoteCoinType>')
  .argument('<lot_size>')
  .argument('<tick_size>')
  .argument('[max_gas]', '', '10000')
  .action(market_register_market_pure_coin);


const market_swap_between_coinstores = async (BaseCoinType: string,QuoteCoinType: string,host: string,market_id: string,direction: string,min_base: string,max_base: string,min_quote: string,max_quote: string,limit_price: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const BaseCoinType_ = parseTypeTagOrThrow(BaseCoinType);
  const QuoteCoinType_ = parseTypeTagOrThrow(QuoteCoinType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const direction_ = direction=='true';
  const min_base_ = u64(min_base);
  const max_base_ = u64(max_base);
  const min_quote_ = u64(min_quote);
  const max_quote_ = u64(max_quote);
  const limit_price_ = u64(limit_price);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_swap_between_coinstores(host_, market_id_, direction_, min_base_, max_base_, min_quote_, max_quote_, limit_price_, [BaseCoinType_, QuoteCoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("market:swap-between-coinstores")
  .description("")
  .argument('<TYPE_BaseCoinType>')
  .argument('<TYPE_QuoteCoinType>')
  .argument('<host>')
  .argument('<market_id>')
  .argument('<direction>')
  .argument('<min_base>')
  .argument('<max_base>')
  .argument('<min_quote>')
  .argument('<max_quote>')
  .argument('<limit_price>')
  .argument('[max_gas]', '', '10000')
  .action(market_swap_between_coinstores);


const registry_init_registry = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Registry.buildPayload_init_registry();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("registry:init-registry")
  .description("")
  .argument('[max_gas]', '', '10000')
  .action(registry_init_registry);


const user_deposit_from_coinstore = async (CoinType: string,market_id: string,general_custodian_id: string,amount: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const market_id_ = u64(market_id);
  const general_custodian_id_ = u64(general_custodian_id);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.User.buildPayload_deposit_from_coinstore(market_id_, general_custodian_id_, amount_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("user:deposit-from-coinstore")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<market_id>')
  .argument('<general_custodian_id>')
  .argument('<amount>')
  .argument('[max_gas]', '', '10000')
  .action(user_deposit_from_coinstore);


const user_register_market_account = async (BaseType: string,QuoteType: string,market_id: string,general_custodian_id: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const market_id_ = u64(market_id);
  const general_custodian_id_ = u64(general_custodian_id);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.User.buildPayload_register_market_account(market_id_, general_custodian_id_, [BaseType_, QuoteType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("user:register-market-account")
  .description("")
  .argument('<TYPE_BaseType>')
  .argument('<TYPE_QuoteType>')
  .argument('<market_id>')
  .argument('<general_custodian_id>')
  .argument('[max_gas]', '', '10000')
  .action(user_register_market_account);


const user_withdraw_to_coinstore = async (CoinType: string,market_id: string,amount: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const market_id_ = u64(market_id);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.User.buildPayload_withdraw_to_coinstore(market_id_, amount_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("user:withdraw-to-coinstore")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<market_id>')
  .argument('<amount>')
  .argument('[max_gas]', '', '10000')
  .action(user_withdraw_to_coinstore);


const aggregator_init_coin_store = async (X: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_init_coin_store([X_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:init-coin-store")
  .description("")
  .argument('<TYPE_X>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_init_coin_store);


const aggregator_init_coin_store_all = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_init_coin_store_all();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:init-coin-store-all")
  .description("")
  .argument('[max_gas]', '', '10000')
  .action(aggregator_init_coin_store_all);


const aggregator_one_step_route = async (X: string,Y: string,E: string,first_dex_type: string,first_pool_type: string,first_is_x_to_y: string,x_in: string,y_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const E_ = parseTypeTagOrThrow(E);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const y_min_out_ = u64(y_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_one_step_route(first_dex_type_, first_pool_type_, first_is_x_to_y_, x_in_, y_min_out_, [X_, Y_, E_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:one-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_E>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<x_in>')
  .argument('<y_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_one_step_route);


const aggregator_swap = async (X: string,Y: string,Z: string,OutCoin: string,E1: string,E2: string,E3: string,num_steps: string,first_dex_type: string,first_pool_type: string,first_is_x_to_y: string,second_dex_type: string,second_pool_type: string,second_is_x_to_y: string,third_dex_type: string,third_pool_type: string,third_is_x_to_y: string,x_in: string,m_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const num_steps_ = u8(num_steps);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const m_min_out_ = u64(m_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_swap(num_steps_, first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, third_dex_type_, third_pool_type_, third_is_x_to_y_, x_in_, m_min_out_, [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:swap")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_OutCoin>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<num_steps>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<third_dex_type>')
  .argument('<third_pool_type>')
  .argument('<third_is_x_to_y>')
  .argument('<x_in>')
  .argument('<m_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_swap);


const aggregator_three_step_route = async (X: string,Y: string,Z: string,M: string,E1: string,E2: string,E3: string,first_dex_type: string,first_pool_type: string,first_is_x_to_y: string,second_dex_type: string,second_pool_type: string,second_is_x_to_y: string,third_dex_type: string,third_pool_type: string,third_is_x_to_y: string,x_in: string,m_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const M_ = parseTypeTagOrThrow(M);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const m_min_out_ = u64(m_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_three_step_route(first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, third_dex_type_, third_pool_type_, third_is_x_to_y_, x_in_, m_min_out_, [X_, Y_, Z_, M_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:three-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_M>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<third_dex_type>')
  .argument('<third_pool_type>')
  .argument('<third_is_x_to_y>')
  .argument('<x_in>')
  .argument('<m_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_three_step_route);


const aggregator_two_step_route = async (X: string,Y: string,Z: string,E1: string,E2: string,first_dex_type: string,first_pool_type: string,first_is_x_to_y: string,second_dex_type: string,second_pool_type: string,second_is_x_to_y: string,x_in: string,z_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const z_min_out_ = u64(z_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_two_step_route(first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, x_in_, z_min_out_, [X_, Y_, Z_, E1_, E2_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:two-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<x_in>')
  .argument('<z_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_two_step_route);


const devnet_mock_deploy_basiq = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_basiq();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("devnet:mock-deploy-basiq")
  .description("Create BTC-USDC pool on econia and add liquidity")
  .argument('[max_gas]', '', '10000')
  .action(devnet_mock_deploy_basiq);


const devnet_mock_deploy_econia = async (market_id: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const market_id_ = u64(market_id);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_econia(market_id_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("devnet:mock-deploy-econia")
  .description("Create BTC-USDC pool on econia and add liquidity")
  .argument('<market_id>')
  .argument('[max_gas]', '', '10000')
  .action(devnet_mock_deploy_econia);


const devnet_mock_deploy_pontem = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_pontem();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("devnet:mock-deploy-pontem")
  .description("Create BTC-USDC pool on pontem and add liquidity")
  .argument('[max_gas]', '', '10000')
  .action(devnet_mock_deploy_pontem);


const volume_clean = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Volume.buildPayload_clean();
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("volume:clean")
  .description("")
  .argument('[max_gas]', '', '10000')
  .action(volume_clean);


const volume_initialize = async (poster: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const poster_ = new HexString(poster);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Volume.buildPayload_initialize(poster_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("volume:initialize")
  .description("")
  .argument('<poster>')
  .argument('[max_gas]', '', '10000')
  .action(volume_initialize);


const volume_set_poster = async (new_poster: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const new_poster_ = new HexString(new_poster);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Volume.buildPayload_set_poster(new_poster_);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("volume:set-poster")
  .description("")
  .argument('<new_poster>')
  .argument('[max_gas]', '', '10000')
  .action(volume_set_poster);


const sample_swap_and_transfer = async (X: string,Y: string,Z: string,OutCoin: string,E1: string,E2: string,E3: string,num_steps: string,first_dex_type: string,first_pool_type: string,first_is_x_to_y: string,second_dex_type: string,second_pool_type: string,second_is_x_to_y: string,third_dex_type: string,third_pool_type: string,third_is_x_to_y: string,x_in: string,target_address: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const num_steps_ = u8(num_steps);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const target_address_ = new HexString(target_address);
  const max_gas_ = parseInt(max_gas);
  const payload = Sample.Sample.buildPayload_swap_and_transfer(num_steps_, first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, third_dex_type_, third_pool_type_, third_is_x_to_y_, x_in_, target_address_, [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("sample:swap-and-transfer")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_OutCoin>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<num_steps>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<third_dex_type>')
  .argument('<third_pool_type>')
  .argument('<third_is_x_to_y>')
  .argument('<x_in>')
  .argument('<target_address>')
  .argument('[max_gas]', '', '10000')
  .action(sample_swap_and_transfer);


const coin_list_fetch_all_registered_coin_info = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const repo = getProjectRepo();
  const value = await Coin_list.Coin_list.query_fetch_all_registered_coin_info(client, getSimulationKeys(account), repo, [], {maxGasAmount: parseInt(max_gas)})
  print(value);
}

program
  .command("coin-list:query-fetch-all-registered-coin-info")
  .argument('[max_gas]', '', '10000')
  .action(coin_list_fetch_all_registered_coin_info)


const coin_list_fetch_full_list = async (list_owner_addr: string, max_gas: string) => {
  const {client, account} = readConfig(program);
  const repo = getProjectRepo();
  const value = await Coin_list.Coin_list.query_fetch_full_list(client, getSimulationKeys(account), repo, new HexString(list_owner_addr), [], {maxGasAmount: parseInt(max_gas)})
  print(value);
}

program
  .command("coin-list:query-fetch-full-list")
  .argument('<list_owner_addr>')
  .argument('[max_gas]', '', '10000')
  .action(coin_list_fetch_full_list)


const volume_fetch_volume = async (max_gas: string) => {
  const {client, account} = readConfig(program);
  const repo = getProjectRepo();
  const value = await Hippo_aggregator.Volume.query_fetch_volume(client, getSimulationKeys(account), repo, [], {maxGasAmount: parseInt(max_gas)})
  print(value);
}

program
  .command("volume:query-fetch-volume")
  .argument('[max_gas]', '', '10000')
  .action(volume_fetch_volume)


const testSwap = async(symbolX: string, symbolY: string, xInAmt: string, targetAddress: string) => {
  const {client, account} = readConfig(program);
  const agg = await TradeAggregator.create(client);
  const xInfo = agg.registryClient.getCoinInfoBySymbol(symbolX);
  const yInfo = agg.registryClient.getCoinInfoBySymbol(symbolY);
  const quote = await agg.getBestQuote(parseFloat(xInAmt), xInfo, yInfo);
  if (!quote) {
    console.log(`No quote from ${symbolX} to ${symbolY}`);
    return;
  }
  const params = quote.route.getSwapParams(parseFloat(xInAmt), 0);
  const payload = buildPayload_swap_and_transfer(
    params.numSteps,
    params.firstDexType,
    params.firstPoolType,
    params.firstIsReversed,
    params.secondDexType,
    params.secondPoolType,
    params.secondIsReversed,
    params.thirdDexType,
    params.thirdPoolType,
    params.thirdIsReversed,
    params.inAmt,
    new HexString(targetAddress),
    params.types
  );

  await sendPayloadTxAndLog(client, account, payload);
}


program
  .command("test-swap")
  .argument("symbolX")
  .argument("symbolY")
  .argument("xInAmt")
  .argument("targetAddress")
  .action(testSwap);


program.parse();
